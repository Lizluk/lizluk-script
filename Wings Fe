--=Bird Wings R15 - Executor Version (Synapse/KRNL/Fluxus)
-- Nháº£y rá»“i nháº¥n Space Ä‘á»ƒ bay | Q = xuá»‘ng | Space = lÃªn | A+A / D+D = xoay
-- âœ¨ FIXED: ToÃ n bá»™ nhÃ¢n váº­t nghiÃªng xuá»‘ng khi bay!

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local plr = Players.LocalPlayer

if _G.wingsCleanup then
    pcall(_G.wingsCleanup)
end

local function startWings()
    local char = plr.Character
    if not char then return end

    local hum = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local tor = char:FindFirstChild("UpperTorso") or char:FindFirstChild("Torso")

    if not hum or not hrp or not tor then
        warn("KhÃ´ng tÃ¬m tháº¥y character parts! Thá»­ láº¡i sau 2 giÃ¢y...")
        task.wait(2)
        startWings()
        return
    end

    pcall(function()
        if char:FindFirstChild("Wings") then
            char.Wings:Destroy()
        end
    end)

    local isR15 = tor.Name == "UpperTorso"
    local mod = Instance.new("Model", char)
    mod.Name = "Wings"

    -- ============ HELPERS ============
    local function lerp(a,b,c) return a+(b-a)*c end

    local function clerp(c1,c2,al)
        local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}
        local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}
        for i,v in pairs(com1) do com1[i] = lerp(v,com2[i],al) end
        return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))
    end

    local function tickwave(time,length,offset)
        return (math.abs((tick()+(offset or 0))%time-time/2)*2-time/2)/time/2*length
    end

    local function mid(a,b,c) return math.max(a,math.min(b,c or -a)) end
    local function bn(a) return a and 1 or 0 end

    local function invcol(c)
        c = c.Color
        return BrickColor.new(Color3.new(1-c.b,1-c.g,1-c.r))
    end

    local function weld(p0,p1,c0,c1)
        local w = Instance.new("Weld",p0)
        w.Part0=p0; w.Part1=p1
        w.C0=c0 or CFrame.new(); w.C1=c1 or CFrame.new()
        return w
    end

    local function motor(p0,p1,c0,c1,des,vel)
        local w = Instance.new("Motor6D",p0)
        w.Part0=p0; w.Part1=p1
        w.C0=c0 or CFrame.new(); w.C1=c1 or CFrame.new()
        w.MaxVelocity=tonumber(vel) or .05
        w.DesiredAngle=tonumber(des) or 0
        return w
    end

    -- ============ PARTS ============
    local topcolor = invcol(tor.BrickColor)
    local feacolor = tor.BrickColor

    local function newpart()
        local p = Instance.new("Part")
        p.FormFactor = "Custom"
        p.Size = Vector3.new(.2,.2,.2)
        p.TopSurface,p.BottomSurface = 0,0
        p.CanCollide = false
        p.BrickColor = topcolor
        p.Transparency = 0
        p.Parent = mod
        p:BreakJoints()
        return p
    end

    local function newfeather()
        local p = newpart()
        p.BrickColor = feacolor
        local m = Instance.new("SpecialMesh",p)
        m.MeshType = Enum.MeshType.Sphere
        m.Scale = Vector3.new(1,1,1)
        return p
    end

    -- ============ BUILD WINGS ============
    local wingOffsetY = isR15 and 0.1 or 0.6
    local wingOffsetZ = isR15 and 0.1 or 0.4

    local function buildWing(side)
        local sx = side

        local p1 = newpart(); p1.Size = Vector3.new(.3,1.5,.3)*1.2
        local m1 = motor(tor, p1,
            CFrame.new(sx*.45, wingOffsetY, wingOffsetZ)
            * CFrame.Angles(0,0,math.rad(-60*sx))
            * CFrame.Angles(math.rad(30),math.rad(-25*sx),0)
            * (sx==-1 and CFrame.Angles(0,-math.pi,0) or CFrame.new()),
            CFrame.new(0,-.8,0), nil, .1)

        local p2 = newpart(); p2.Size = Vector3.new(.4,1.8,.4)*1.2
        local m2 = motor(p1,p2,
            CFrame.new(0,.75,0)*CFrame.Angles(0,0,math.rad(50))*CFrame.Angles(math.rad(-30)*sx,math.rad(15*sx),0),
            CFrame.new(0,-.9,0),nil,.1)

        local p3 = newpart(); p3.Size = Vector3.new(.3,2.2,.3)*1.2
        local m3 = motor(p2,p3,
            CFrame.new(.1,.9,0)*CFrame.Angles(0,0,math.rad(-140))*CFrame.Angles(math.rad(-3*sx),0,0),
            CFrame.new(0,-1.1,0),nil,.1)

        local p4 = newpart(); p4.Size = Vector3.new(.25,1.2,.25)*1.2
        local m4 = motor(p3,p4,
            CFrame.new(0,1.1,0)*CFrame.Angles(0,0,math.rad(-10))*CFrame.Angles(math.rad(-3*sx),0,0),
            CFrame.new(0,-.6,0),nil,.1)

        local f = newfeather(); f.Size = Vector3.new(.4,3,.3)
        weld(p4,f,CFrame.new(-.1,-.3,0),CFrame.new(0,-1.5,0))
        f = newfeather(); f.Size = Vector3.new(.4,2.3,.3)
        weld(p4,f,CFrame.new(.1,-.1,0)*CFrame.Angles(0,math.random()*.1,0),CFrame.new(0,-1.1,0))
        f = newfeather(); f.Size = Vector3.new(.35,2.2,.25)
        weld(p4,f,CFrame.new(.1,-.3,0)*CFrame.Angles(0,math.random()*.1,math.rad(-10)),CFrame.new(0,-1.1,0))

        local frow3,frow2,frow1 = {},{},{}
        for i=0,7 do
            f=newfeather(); f.Size=Vector3.new(.45,2.2,.35)
            table.insert(frow3,motor(p3,f,CFrame.new(.05,1-i*.285,0)*CFrame.Angles(0,math.random()*.1,math.rad(-25-i*2)),CFrame.new(0,-f.Size.Y/2,0)))
        end
        for i=0,6 do
            f=newfeather(); f.Size=Vector3.new(.45,2.2-i*.08,.3)
            table.insert(frow2,motor(p2,f,CFrame.new(.05,.75-i*.26,0)*CFrame.Angles(0,math.random()*.1,math.rad(-75-i*4)),CFrame.new(0,-f.Size.Y/2,0)))
        end
        for i=0,6 do
            f=newfeather(); f.Size=Vector3.new(.37,1.65-i*.06,.25)
            table.insert(frow1,motor(p1,f,CFrame.new(.05,.63-i*.21,0)*CFrame.Angles(0,math.random()*.05,math.rad(-75)),CFrame.new(0,-f.Size.Y/2,0)))
        end

        return {m1,m2,m3,m4}, frow1, frow2, frow3
    end

    local rwing,rf1,rf2,rf3 = buildWing(1)
    local lwing,lf1,lf2,lf3 = buildWing(-1)

    local oc0 = {}
    for _,v in pairs(rwing) do oc0[v]=v.C0 end
    for _,v in pairs(lwing) do oc0[v]=v.C0 end

    -- ============ POSES ============
    local idle     = {0,0.5,-.2,0,   .05,.05,.1,.05, -.6,-1.5,.1,0}
    local outlow   = {-.7,-.2,1.8,0, .3,.05,.1,.05,  .2,0,0,0}
    local outhigh  = {.5,-.2,1.8,0,  .3,.05,.1,.05,  .2,0,0,0}
    local veryhigh = {.9,-.3,1.9,0,  .3,.05,.1,.05,  .2,0,0,0}
    local flap1    = {-.3,.3,1.1,-.2,.3,.05,.1,.05,  .2,-.6,0,0}
    local divebomb = {0,.2,.4,-.7,   .3,.05,.1,.05,  0,-.5,-.6,0}

    local function setwings(tab,t)
        t = t or 10
        for i=1,4 do
            rwing[i].DesiredAngle=tab[i]; lwing[i].DesiredAngle=tab[i]
            rwing[i].MaxVelocity=math.abs(tab[i]-rwing[i].CurrentAngle)/t
            lwing[i].MaxVelocity=math.abs(tab[i]-lwing[i].CurrentAngle)/t
        end
        local sets = {rf1,lf1,rf2,lf2,rf3,lf3}
        local vals = {9,9,10,10,11,11}
        for i,g in pairs(sets) do
            for _,v in pairs(g) do
                v.DesiredAngle=tab[vals[i]]
                v.MaxVelocity=math.abs(v.DesiredAngle-v.CurrentAngle)/t
            end
        end
    end

    setwings(outhigh,1)

    -- ============ PHYSICS ============
    for _,v in pairs(hrp:GetChildren()) do
        if v.ClassName:lower():match("body") then v:Destroy() end
    end

    -- âœ¨ DÃ™NG ALIGNORIENTATION THAY VÃŒ BODYGYRO
    local alignOrient = Instance.new("AlignOrientation", hrp)
    alignOrient.Mode = Enum.OrientationAlignmentMode.OneAttachment
    alignOrient.MaxTorque = 100000
    alignOrient.Responsiveness = 15
    alignOrient.Enabled = false

    local attachment = Instance.new("Attachment", hrp)
    alignOrient.Attachment0 = attachment

    local bv = Instance.new("BodyVelocity",hrp)
    bv.maxForce = Vector3.new(); bv.P=15000; bv.velocity=Vector3.new()

    -- ============ STATE ============
    local flying,moving = false,false
    local fldir = Vector3.new(0,0,-1)
    local idledir = Vector3.new(0,0,-1)
    local vel = Vector3.new()
    local cf = CFrame.new()
    local flspd,flystart,reqrotx = 0,0,0
    local grav = 196.2
    local descendtimer,jumptime = tick(),tick()
    local keysdown,keypressed,ktime = {},{},{}
    local cam = workspace.CurrentCamera
    local alive = true
    local connections = {}

    -- ============ INPUT ============
    local mouse = plr:GetMouse()

    local function addConn(c) table.insert(connections,c) end

    addConn(mouse.KeyDown:Connect(function(key)
        key = key:lower()
        keysdown[key]=true; keypressed[key]=true
        if key=="f" then descendtimer=tick()
        elseif key=="q" then jumptime=tick()
        elseif (key=="a" or key=="d") and ktime[key] and tick()-ktime[key]<.3 and math.abs(reqrotx)<.3 then
            reqrotx = key=="a" and math.pi*2 or -math.pi*2
        end
        ktime[key]=tick()
    end))

    addConn(mouse.KeyUp:Connect(function(key)
        key=key:lower(); keysdown[key]=false
        if key==" " then descendtimer=tick() end
    end))

    addConn(hum.Jumping:Connect(function() jumptime=tick() end))

    addConn(hum.Died:Connect(function()
        alive=false; flying=false
        hum.PlatformStand=false
        alignOrient.Enabled = false
        bv.maxForce=Vector3.new()
    end))

    -- ============ MAIN LOOP ============
    addConn(RunService.Heartbeat:Connect(function()
        if not alive then return end
        if not char.Parent then alive=false; return end

        local vel3 = hrp.AssemblyLinearVelocity
        local obvel = hrp.CFrame:vectorToObjectSpace(vel3)
        local sspd,uspd,fspd2 = obvel.X,obvel.Y,obvel.Z

        if flying then
            local lfldir = fldir
            fldir = cam.CoordinateFrame:vectorToWorldSpace(
                Vector3.new(bn(keysdown.d)-bn(keysdown.a),0,bn(keysdown.s)-bn(keysdown.w))
            ).unit

            local lmoving = moving
            moving = fldir.magnitude>.1
            if lmoving and not moving then
                idledir=lfldir*Vector3.new(1,0,1); descendtimer=tick()
            end

            local dbomb = fldir.Y<-.6 or (moving and keysdown["1"])
            if moving and keysdown["0"] and lmoving then
                fldir=(Vector3.new(lfldir.X,math.min(fldir.Y,lfldir.Y+.01)-.1,lfldir.Z)+(fldir*Vector3.new(1,0,1))*.05).unit
            end

            local down = hrp.CFrame:vectorToWorldSpace(Vector3.new(0,-1,0))
            local descending = not moving and keysdown["q"] and not keysdown[" "]

            -- âœ¨ TÃNH TOÃN HÆ¯á»šNG Má»¤C TIÃŠU
            local targetLook = not moving and idledir or fldir
            cf = CFrame.new(hrp.Position, hrp.Position + targetLook)
            
            local gdown = not dbomb and cf.lookVector.Y<-.2 and vel3.unit.Y<.05

            -- âœ¨ Táº®T HUMANOID CONTROL VÃ€ DÃ™NG ALIGNORIENTATION
            hum.PlatformStand = true  -- Báº­t Ä‘á»ƒ táº¯t humanoid physics
            hum.AutoRotate = false
            
            alignOrient.Enabled = true
            
            -- TÃNH GÃ“C NGHIÃŠNG
            local pitchAngle = -0.1
            local rollAngle = 0
            
            if moving then
                -- Bay vá» phÃ­a trÆ°á»›c
                pitchAngle = math.rad(-65)  -- NghiÃªng xuá»‘ng 65 Ä‘á»™
                
                -- Äiá»u chá»‰nh theo hÆ°á»›ng dá»c
                if fldir.Y < -0.3 then
                    pitchAngle = math.rad(-85)  -- Lao xuá»‘ng
                elseif fldir.Y > 0.2 then
                    pitchAngle = math.rad(-35)  -- Bay lÃªn
                end
                
                -- Roll nháº¹ khi xoay
                local rotvel = CFrame.new(Vector3.new(),vel3):toObjectSpace(CFrame.new(Vector3.new(),fldir)).lookVector
                rollAngle = mid(-0.5, rotvel.X/2)
            end
            
            -- Set orientation
            local targetCF = cf * CFrame.Angles(pitchAngle, reqrotx, rollAngle)
            alignOrient.CFrame = targetCF
            
            reqrotx = reqrotx * 0.9

            bv.maxForce = Vector3.new(1,1,1)*9e4*.5
            local anioff=(bn(keysdown[" "])-bn(keysdown["q"]))/2
            local ani=tickwave(1.5-anioff,1)

            bv.velocity=bv.velocity:Lerp(
                Vector3.new(0,bn(not moving)*-ani*15+(descending and math.min(20,tick()-descendtimer)*-8 or bn(keysdown[" "])-bn(keysdown["q"]))*15,0)+vel,
                .6)
            vel=moving and cf.lookVector*flspd or Vector3.new()
            flspd=math.min(450,lerp(flspd,moving and (fldir.Y<0 and flspd+(-fldir.Y)*grav/60 or math.max(450,flspd-fldir.Y*grav/200)) or 60,.4))

            setwings(moving and (gdown and outlow or dbomb and divebomb) or (descending and veryhigh or flap1),15)

            for i=1,4 do
                rwing[i].C0=clerp(rwing[i].C0,oc0[rwing[i]]*(
                    gdown and CFrame.new() or
                    dbomb and CFrame.Angles(-.5+bn(i==3)*.4+bn(i==4)*.5,.1+bn(i==2)*.5-bn(i==3)*1.1,bn(i==3)*.1) or
                    descending and CFrame.Angles(.3,0,0) or
                    CFrame.Angles((i*.1+1.5)*ani,ani*-.5,1*ani)
                ),descending and .8 or .2)
                lwing[i].C0=clerp(lwing[i].C0,oc0[lwing[i]]*(
                    gdown and CFrame.new() or
                    dbomb and CFrame.Angles(-(-.5+bn(i==3)*.4+bn(i==4)*.5),-(.1+bn(i==2)*.5-bn(i==3)*1.1),bn(i==3)*.1) or
                    descending and CFrame.Angles(-.3,0,0) or
                    CFrame.Angles(-(i*.1+1.5)*ani,ani*.5,1*ani)
                ),descending and .8 or .2)
            end

            local hit=workspace:FindPartOnRayWithIgnoreList(Ray.new(hrp.Position,Vector3.new(0,-3.5+math.min(0,bv.velocity.y)/30,0)),{char})
            if hit and down.Y<-.85 and tick()-flystart>1 then
                flying=false
                alignOrient.Enabled = false
                bv.maxForce=Vector3.new()
                hrp.AssemblyLinearVelocity=Vector3.new()
                hum.PlatformStand=false
                hum.AutoRotate = true
            end

        else
            alignOrient.Enabled = false
            hum.PlatformStand=false
            hum.AutoRotate = true
            bv.maxForce=Vector3.new()
            
            local walking=hum.MoveDirection.magnitude>0
            local ani=tickwave(walking and .8 or 4.5,1)
            setwings(idle,10)
            local x,y,z=fspd2/160,uspd/700,sspd/900
            for i=1,4 do
                rwing[i].C0=clerp(rwing[i].C0,oc0[rwing[i]]*CFrame.Angles(ani*.1+-mid(-.1,x),0+-mid(-.1,y)+bn(i==2)*.6,ani*.02+-mid(-.1,z)),.2)
                lwing[i].C0=clerp(lwing[i].C0,oc0[lwing[i]]*CFrame.Angles(ani*-.05+mid(-.1,x),0+mid(-.1,y)+-bn(i==2)*.6,ani*.02+mid(-.1,z)),.2)
            end

            if keypressed[" "] and not flying and tick()-jumptime>.05 and tick()-jumptime<3 then
                vel=Vector3.new(0,50,0); bv.velocity=vel
                idledir=cam.CoordinateFrame.lookVector*Vector3.new(1,0,1)
                cf=hrp.CFrame*CFrame.Angles(-.01,0,0)
                flystart=tick(); flying=true
            end
        end
        keypressed={}
    end))

    -- ============ CLEANUP ============
    local function cleanup()
        alive=false
        for _,c in pairs(connections) do pcall(function() c:Disconnect() end) end
        pcall(function() alignOrient:Destroy() end)
        pcall(function() attachment:Destroy() end)
        pcall(function() bv:Destroy() end)
        pcall(function() mod:Destroy() end)
        hum.PlatformStand=false
        hum.AutoRotate = true
    end

    _G.wingsCleanup = cleanup
    return cleanup
end

startWings()

plr.CharacterAdded:Connect(function()
    task.wait(1)
    startWings()
end)

print("âœ¨ Wings V3 loaded!")
print("ðŸ¦… Nháº£y + Space = bay, nhÃ¢n váº­t sáº½ NGHIÃŠNG XUá»NG khi bay!")
